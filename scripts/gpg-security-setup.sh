#!/bin/bash
# gpg-security-setup.sh - Secure GPG key management and backup

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== GPG Security Setup ===${NC}"
echo -e "${YELLOW}This script will help secure and backup your GPG keys${NC}"
echo ""

# Configuration
GPG_KEY_ID="${1:-}"  # Pass key ID as first argument
BACKUP_DIR="$HOME/InstallOS/private/gpg-backup-$(date +%Y%m%d)"

# Check if key ID provided
if [ -z "$GPG_KEY_ID" ]; then
    echo -e "${RED}Error: No GPG key ID provided${NC}"
    echo "Usage: $0 <GPG_KEY_ID>"
    echo "Find your key ID with: gpg --list-secret-keys"
    exit 1
fi

# Function to check if key has passphrase
check_passphrase_protection() {
    local key_id="$1"
    echo -e "${YELLOW}Checking passphrase protection...${NC}"
    
    # Try to sign something - it should ask for passphrase
    if echo "test" | gpg --armor --detach-sign --local-user "$key_id" >/dev/null 2>&1; then
        echo -e "${YELLOW}⚠ WARNING: No passphrase required - key might not be protected!${NC}"
        return 1
    else
        echo -e "${GREEN}✓ Key appears to be passphrase protected${NC}"
        return 0
    fi
}

# Function to create secure backup
create_secure_backup() {
    echo -e "${YELLOW}Creating secure GPG backup...${NC}"
    
    # Create backup directory
    mkdir -p "$BACKUP_DIR"
    chmod 700 "$BACKUP_DIR"
    
    # Export public key
    echo -e "${YELLOW}Exporting public key...${NC}"
    gpg --armor --export "$GPG_KEY_ID" > "$BACKUP_DIR/public-key.asc"
    
    # Export private key (will prompt for passphrase)
    echo -e "${YELLOW}Exporting private key (you'll be prompted for passphrase)...${NC}"
    gpg --armor --export-secret-keys "$GPG_KEY_ID" > "$BACKUP_DIR/private-key.asc"
    
    # Export subkeys
    echo -e "${YELLOW}Exporting subkeys...${NC}"
    gpg --armor --export-secret-subkeys "$GPG_KEY_ID" > "$BACKUP_DIR/subkeys.asc"
    
    # Export trust database
    echo -e "${YELLOW}Exporting trust database...${NC}"
    gpg --export-ownertrust > "$BACKUP_DIR/trustdb.txt"
    
    # Create revocation certificate if it doesn't exist
    REVOKE_CERT="$HOME/.gnupg/openpgp-revocs.d/${GPG_KEY_ID}.rev"
    if [ ! -f "$REVOKE_CERT" ]; then
        echo -e "${YELLOW}Creating revocation certificate...${NC}"
        gpg --gen-revoke "$GPG_KEY_ID" > "$BACKUP_DIR/revocation-cert.asc"
    else
        cp "$REVOKE_CERT" "$BACKUP_DIR/revocation-cert.asc"
    fi
    
    # Set secure permissions
    chmod 600 "$BACKUP_DIR"/*.asc "$BACKUP_DIR"/*.txt
    
    # Create backup info
    cat > "$BACKUP_DIR/backup-info.txt" << EOF
GPG Key Backup Information
=========================
Created: $(date)
Key ID: $GPG_KEY_ID
Key Fingerprint: $(gpg --fingerprint "$GPG_KEY_ID" | grep -A1 "pub" | tail -1 | tr -d ' ')

Files in this backup:
- public-key.asc: Your public key (safe to share)
- private-key.asc: Your private key (KEEP SECURE!)
- subkeys.asc: Your subkeys
- trustdb.txt: Trust relationships
- revocation-cert.asc: Emergency revocation certificate

To restore:
1. gpg --import public-key.asc
2. gpg --import private-key.asc
3. gpg --import-ownertrust < trustdb.txt
4. gpg --edit-key $GPG_KEY_ID trust (set to ultimate)

IMPORTANT: Store this backup in multiple secure locations!
- Encrypted USB drive
- Encrypted cloud storage (additional encryption)
- Safe deposit box (on encrypted media)
EOF
    
    echo -e "${GREEN}✓ Backup created in: $BACKUP_DIR${NC}"
}

# Function to enhance GPG configuration
enhance_gpg_config() {
    echo -e "${YELLOW}Enhancing GPG configuration...${NC}"
    
    # Create or update gpg.conf
    GPG_CONF="$HOME/.gnupg/gpg.conf"
    
    # Backup existing config
    if [ -f "$GPG_CONF" ]; then
        cp "$GPG_CONF" "$GPG_CONF.backup-$(date +%Y%m%d)"
    fi
    
    # Create secure GPG configuration
    cat > "$GPG_CONF" << 'EOF'
# GPG Configuration - Security Hardened
# Generated by InstallOS security setup

# Default key (set to your key ID)
# default-key YOUR_KEY_ID_HERE

# Crypto preferences
personal-cipher-preferences AES256 AES192 AES
personal-digest-preferences SHA512 SHA384 SHA256
personal-compress-preferences ZLIB BZIP2 ZIP Uncompressed
default-preference-list SHA512 SHA384 SHA256 AES256 AES192 AES ZLIB BZIP2 ZIP Uncompressed

# Security settings
cert-digest-algo SHA512
s2k-digest-algo SHA512
s2k-cipher-algo AES256
charset utf-8
no-comments
no-emit-version
no-greeting
keyid-format 0xlong
list-options show-uid-validity
verify-options show-uid-validity
with-fingerprint
require-cross-certification
no-symkey-cache
throw-keyids

# Display settings
use-agent
armor

# Key server settings (use Tor if available)
# keyserver hkps://keys.openpgp.org
# keyserver-options no-honor-keyserver-url
# keyserver-options include-revoked

# Auto key retrieval
# auto-key-retrieve
# auto-key-locate cert pka ldap keyserver

# Trust model
trust-model tofu+pgp
EOF
    
    # Create or update gpg-agent.conf
    AGENT_CONF="$HOME/.gnupg/gpg-agent.conf"
    cat > "$AGENT_CONF" << 'EOF'
# GPG Agent Configuration
# Generated by InstallOS security setup

# Cache settings (in seconds)
default-cache-ttl 600
maximum-cache-ttl 7200
default-cache-ttl-ssh 1800
max-cache-ttl-ssh 7200

# Security
enforce-passphrase-constraints
min-passphrase-len 12
min-passphrase-nonalpha 2

# Pinentry program
pinentry-program /usr/bin/pinentry-gnome3

# SSH support
enable-ssh-support

# Extra socket for remote forwarding
# extra-socket /run/user/1000/gnupg/S.gpg-agent.extra
EOF
    
    # Set secure permissions
    chmod 600 "$GPG_CONF" "$AGENT_CONF"
    
    # Reload gpg-agent
    gpg-connect-agent reloadagent /bye
    
    echo -e "${GREEN}✓ GPG configuration enhanced${NC}"
}

# Function to test GPG setup
test_gpg_setup() {
    echo -e "${YELLOW}Testing GPG setup...${NC}"
    
    # Test signing
    echo "Test message" > /tmp/test-gpg.txt
    if gpg --detach-sign --armor /tmp/test-gpg.txt; then
        echo -e "${GREEN}✓ Signing works${NC}"
        gpg --verify /tmp/test-gpg.txt.asc /tmp/test-gpg.txt
        rm -f /tmp/test-gpg.txt /tmp/test-gpg.txt.asc
    else
        echo -e "${RED}✗ Signing failed${NC}"
    fi
    
    # Test encryption to self
    echo "Secret message" | gpg --encrypt --armor -r "$GPG_KEY_ID" > /tmp/test-encrypted.asc
    if gpg --decrypt /tmp/test-encrypted.asc 2>/dev/null | grep -q "Secret message"; then
        echo -e "${GREEN}✓ Encryption/Decryption works${NC}"
    else
        echo -e "${RED}✗ Encryption/Decryption failed${NC}"
    fi
    rm -f /tmp/test-encrypted.asc
}

# Main execution
echo -e "${BLUE}Current GPG Key Information:${NC}"
gpg --list-secret-keys "$GPG_KEY_ID"
echo ""

# Check passphrase protection
if ! check_passphrase_protection "$GPG_KEY_ID"; then
    echo -e "${RED}⚠ CRITICAL: Your GPG key might not have a passphrase!${NC}"
    echo -e "${YELLOW}Would you like to add/change the passphrase? (y/n)${NC}"
    read -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        gpg --edit-key "$GPG_KEY_ID" passwd save
    fi
fi

# Create backup
echo ""
echo -e "${YELLOW}Create secure backup of GPG keys? (y/n)${NC}"
read -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    create_secure_backup
fi

# Enhance configuration
echo ""
echo -e "${YELLOW}Enhance GPG security configuration? (y/n)${NC}"
read -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    enhance_gpg_config
fi

# Test setup
echo ""
test_gpg_setup

echo ""
echo -e "${BLUE}=== GPG Security Checklist ===${NC}"
echo "[ ] GPG key has strong passphrase"
echo "[ ] Backup stored in secure location"
echo "[ ] Revocation certificate created"
echo "[ ] Using hardware token (YubiKey) for signing"
echo "[ ] Regular key expiration date set"
echo "[ ] Secure GPG configuration applied"

echo ""
echo -e "${GREEN}GPG security setup complete!${NC}"